package wooga.gradle.dotnetsonar.utils

import nebula.test.functional.ExecutionResult
import org.gradle.internal.impldep.org.apache.commons.lang.StringUtils

import java.nio.file.Path

import static SpecUtils.isWindows

class FakeExecutable {

    static File argsReflector(Path fakeFilePath, int exitCode, boolean overwrites=true) {
        File fakeExec = fakeFilePath.toFile()
        if(fakeExec.exists()) {
            if(overwrites) {
                fakeExec.delete()
            } else {
                throw new IllegalArgumentException("File ${fakeFilePath} already exists")
            }
        }
        fakeExec.createNewFile()
        fakeExec.executable = true
        if (isWindows()) {
            fakeExec << """
                @echo off
                echo [[${fakeExec.name}]]
                echo [[arguments]]
                echo %*
                echo [[environment]]
                set
                echo [[end]]
                echo [[end ${fakeExec.name}]]
                exit ${exitCode}
            """.stripIndent()
        } else {
            fakeExec << """
                #!/usr/bin/env bash
                echo [[${fakeExec.name}]]
                echo [[arguments]]
                echo \$@
                echo [[environment]]
                env
                echo [[end]]
                echo [[end ${fakeExec.name}]]
                exit ${exitCode}
            """.stripIndent()
        }
    }

    static Result lastExecutionResults(ExecutionResult executionResult) {
        return new Result(executionResult.standardOutput)
    }

    static Result executionResults(File file, ExecutionResult executionResult) {
        return new Result(file, executionResult.standardOutput)
    }

    static class Result {
        private final File file;
        private final ArrayList<String> args;
        private final Map<String, String> envs;

        Result(String stdOutput) {
            this(null, stdOutput)
        }

        Result(File file, String stdOutput) {
            this.file = file
            this.args = loadArgs(file, stdOutput)
            this.envs = loadEnvs(file, stdOutput)
        }

        ArrayList<String> getArgs() {
            return args
        }

        Map<String, String> getEnvs() {
            return envs
        }

        private static ArrayList<String> loadArgs(File file, String stdOutput) {
            def logs = stdOutput
            if(file != null) {
                logs = substringBetween(stdOutput, "[[${file.name}]]", "[[end ${file.name}]]")
            }
            loadArgs(logs)
        }

        private static Map<String, String> loadEnvs(File file, String stdOutput) {
            def logs = stdOutput
            if(file != null) {
                logs = substringBetween(stdOutput, "[[${file.name}]]", "[[end ${file.name}]]")
            }
            return loadEnvs(logs)
        }

        private static ArrayList<String> loadArgs(String stdOutput) {
            def lastExecutionOffset = stdOutput.lastIndexOf("[[arguments]]")
            if(lastExecutionOffset < 0) {
                throw new IllegalArgumentException("stdout does not contains a execution of a file generated by " +
                        "FakeExecutable.argsReflector")
            }
            def lastExecTailString = stdOutput.substring(lastExecutionOffset)
            def argsString = substringBetween(lastExecTailString, "[[arguments]]", "[[environment]]").
                                replace("[[arguments]]", "")
            def parts = argsString.split(" ").
                    findAll {!StringUtils.isEmpty(it) }.collect{ it.trim() }
            return parts
        }

        private static Map<String, String> loadEnvs(String stdOutput) {
            def argsString = substringBetween(stdOutput, "[[environment]]", "[[end]]").
                    replace("[[environment]]", "")
            def parts = argsString.split(System.lineSeparator()).
                    findAll {!StringUtils.isEmpty(it) }.collect{ it.trim() }
            return parts.collectEntries {
                return it.split("=", 2)
            }
        }
    }

    private static String substringBetween(String base, String from, String to) {
        def customArgsIndex = base.indexOf(from)
        def tailString = base.substring(customArgsIndex)
        def endIndex = tailString.indexOf(to)
        return tailString.substring(0, endIndex)
    }
}
